# Creating a Custom async Validator

We use async validator when we need to send an HTTP request to the server to check if the data entered in a form element is valid or not.

- The async validator must return either a **`promise`** or an **`observable`**.
- Angular does not provide any built-in async validator

##### Custom Validator service

```ts
export class CustomValidators {
    static noSpaceAllowed(control: FormControl){
        if (control.value != null && control.value.indexOf(' ') != -1) {
            return { noSpaceAllowed: true }
        } else {
            return null
        }
    }
    static validPinCode(control: FormControl) {
        if(control.value != null && control.value.toString().length !== 6){
            return { validPinCode: true }
        }else{
            return null
        }
    }

    // Async Validator
    static checkUsername (control: AbstractControl) : Promise<any> {
        const takenUserNames = ['admin', 'user', 'suyash', 'param'];

        return new Promise((resolve, reject) => {
            setTimeout(() => {
                if(takenUserNames.includes(control.value)){
                    resolve({isUsernameAllowed: true});
                }
                else{
                    resolve(null);
                }
            }, 5000);
        });
    }
}
```

```ts

ngOnInit(): void {
    this.reactiveForm = new FormGroup({
      firstName: new FormControl('',[Validators.required,CustomValidators.noSpaceAllowed]),
      lastName: new FormControl('',Validators.required),
      email: new FormControl('',[Validators.required,Validators.email]),
      username: new FormControl('',Validators.required,CustomValidators.checkUsername),
      addressDetails: new FormGroup({
        street: new FormControl('',Validators.required),
        country:new FormControl('',Validators.required),
        city:new FormControl('',Validators.required),
        region:new FormControl('',Validators.required),
        postalCode:new FormControl('',[Validators.required,CustomValidators.validPinCode])
      }),
    })
  }
```

# ValueChanges & stateChanges Events

### The ValueChanges() Event
The ValueChanges is an event which is raised by Angular forms ehenever the value of the FormControl, FormGroup or FormArray changes.

```ts
 ngOnInit(): void {
    this.reactiveForm = new FormGroup({
      firstName: new FormControl(null, Validators.required, 
      addressDetails: new FormGroup({
        street: new FormControl(null, Validators.required),
        country: new FormControl('India', Validators.required),
        city: new FormControl(null, Validators.required),
        region: new FormControl(null),
        postal: new FormControl(null, Validators.required),
      }),
    })

    //* ValueChanges Event on FormControl
    this.reactiveForm.get('firstName').valueChanges.subscribe((value)=>{
      console.log(value)
    })

    //* ValueChanges Event on FormGroup
    this.reactiveForm.get('addressDetails').valueChanges.subscribe((value)=>{
      console.log(value);
    })

  }
```

### The satatusChanges Event
The satatusChanges is an event which is raised by Angular forms whenever Angular calculates status of a FormControl, FormGroup or FormArray changes.

```html
<section [ngClass]="formStatus" class="container">
  <header>Registration Form</header>
  <form class="form" [formGroup]="reactiveForm" (ngSubmit)="OnSubmitForm()"></form>
</section>
```

```ts

formStatus:string =''

 ngOnInit(): void {
    this.reactiveForm = new FormGroup({
      firstName: new FormControl(null, Validators.required, 
      addressDetails: new FormGroup({
        street: new FormControl(null, Validators.required),
        country: new FormControl('India', Validators.required),
        city: new FormControl(null, Validators.required),
        region: new FormControl(null),
        postal: new FormControl(null, Validators.required),
      }),
    })

      //* StatusChanges Event on FormControl
    this.reactiveForm.get('username').statusChanges.subscribe((status)=>{
      console.log(status);
    })

    //* StatusChanges Event on FormGroup
    this.reactiveForm.statusChanges.subscribe((status)=>{
      console.log(status);
      this.formStatus = status;
    })

  }
```

# setValue() and patchValue() Methods

### The setValue() method

- The setValue() method is used to update a FormControl, FormGroup or FormArray value.
- To the setValue() method, we pass an object to update the value of a FormControl, FormGroup or FormArray. The structure of that object must match the structure of FormControl, FormGroup or FormArray which we are trying to update.

```html
<div class="input-box">
        <input type="text"  formControlName="username" placeholder="username" />
        <button class="btn-gen-username" 
        [disabled]="!(reactiveForm.get('firstName').value && reactiveForm.get('lastName').value) && reactiveForm.get('dob').value " 
        (click)="generateUsername()" type="button">
          Create a Username
        </button>
</div>
```

```ts
  generateUsername(){
    let username = 'suysin2024';
   
    //* Updating value using setValue method 
    // Directly accessing formGroup
    //  this.reactiveForm.setValue({
    //    firstName: this.reactiveForm.get('firstName').value,
    //    lastName: this.reactiveForm.get('lastName').value,
    //    email: this.reactiveForm.get('email').value,
    //    username: username,
    //    dob: this.reactiveForm.get('dob').value,
    //    gender: this.reactiveForm.get('gender').value,
    //    addressDetails: {
    //      street: this.reactiveForm.get('address.street').value,
    //      country: this.reactiveForm.get('address.country').value,
    //      city: this.reactiveForm.get('address.city').value,
    //      region: this.reactiveForm.get('address.region').value,
    //      postal: this.reactiveForm.get('address.postal').value,
    //    },
    //    skills: this.reactiveForm.get('skills').value,
    //    experience: this.reactiveForm.get('experience').value
    //  }) 
   
   //todo   Directly accessing formControl
    this.reactiveForm.get('username').setValue(username)
}

```

### The patchValue() method
The patchValue() method is used only a subset of the element od FormGroup or FormArray value.
It will only update the matching objects and ignores the rest.

```html
<div class="input-box">
        <input type="text"  formControlName="username" placeholder="username" />
        <button class="btn-gen-username" 
        [disabled]="!(reactiveForm.get('firstName').value && reactiveForm.get('lastName').value) && reactiveForm.get('dob').value " 
        (click)="generateUsername()" type="button">
          Create a Username
        </button>
</div>
```

```ts
  generateUsername(){
    let username = 'suysin2024';
   
   //todo   Directly accessing formControl
    this.reactiveForm.patchValue({
      username:username,
      addressDetails:{
        city:'New Delhi'
      }
    })
}
```

# Resetting Form Data 

To reset the for use **`reset`** method

```ts
  OnSubmitForm() {
    console.log(this.reactiveForm.value);
    this.formData = this.reactiveForm.value    
    this.reactiveForm.reset() //* For Resetting the form
  }
```

# AbstractControl vs. FormControl
- FormControl is a specific class for form inputs, but:
    - FormGroup represents a group of form controls.
    - FormArray represents an array of form controls.
- AbstractControl is the base class that all of these (FormControl, FormGroup, and FormArray) extend. This makes it more flexible for validators because a validator might be applied to a FormControl, FormGroup, or FormArray.

```ts
import { AbstractControl, ValidationErrors } from '@angular/forms';

export class CustomValidators {
  static noSpaceAllowed(control: AbstractControl): ValidationErrors | null {
    if (control.value && control.value.indexOf(' ') !== -1) {
      return { noSpaceAllowed: true };
    }
    return null;
  }
}

```

### Key Takeaways:
- AbstractControl is the parent class of all form controls (FormControl, FormGroup, FormArray), making it the best choice for custom validators.
- Using FormControl in a validator restricts the validator to only work with FormControl instances, causing type errors when applied to FormGroup or FormArray.
- Angular expects validators to be flexible, which is why it uses AbstractControl.